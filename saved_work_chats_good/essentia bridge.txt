Thank you for sharing the essentia_bridge.py and essentia_runner.py files, and for requesting the Phase 4 plugins for your AI Music Assistant. The shared files indicate you’re using a Windows Subsystem for Linux (WSL) setup to bridge Essentia analysis between Windows and Ubuntu, which is a clever way to handle Essentia’s compatibility challenges on Windows. This context helps ensure the Phase 4 plugins integrate smoothly with your existing system, including the WSL-based Essentia workflow.
Context and Approach
Phase 4 Plugins: As requested, I’ll provide the three Phase 4 plugins (musicxml_converter.py, score_engraver.py, musicxml_validator.py) for MusicXML Export & Score Engraving, as outlined in your roadmap (Phase 4: MusicXML Export & Score Engraving). These will:
Use input_type="midi" for musicxml_converter.py and input_type="musicxml" for score_engraver.py and musicxml_validator.py, aligning with your pipeline.
Integrate with your plugin_registry.py and the updated main.py (supporting musicxml_dir).
Be compatible with Phases 1-3 plugins and the WSL-based Essentia setup.
Essentia Bridge:
essentia_bridge.py is a Windows-side plugin that calls essentia_runner.py in WSL Ubuntu, translating Windows paths to WSL-compatible paths (e.g., C:\path\to\file to /mnt/c/path/to/file).
essentia_runner.py performs Essentia analysis (BPM, RMS, zero-crossing rate, spectral centroid) and returns JSON results.
This suggests your audio_features.py (Phase 1) might be redundant or complementary to essentia_bridge.py. I’ll ensure Phase 4 plugins don’t conflict with this setup and provide guidance on managing Essentia dependencies in WSL.
WSL Considerations:
The Phase 4 plugins will account for your WSL environment, especially for score_engraver.py, which uses MuseScore. I’ll provide WSL-specific installation instructions.
I’ll address your previous download issues (e.g., phase2_plugins.zip) by offering a ZIP or GitHub Gist for all plugins.
Below are the full Phase 4 plugins, followed by an integration guide tailored to your WSL setup, including how to handle the Essentia bridge and ensure compatibility with all phases.
Phase 4 Plugins
1. src/musicxml_converter.py
Converts MIDI files (e.g., from Phase 2’s midi_analysis.py or Phase 3’s audio_to_midi.py) to MusicXML using music21, incorporating analysis data where possible.
python
# File: src/musicxml_converter.py
"""
MusicXML Converter Plugin
Converts MIDI files to MusicXML format, incorporating analysis data using music21.
"""
import os
from typing import Dict
from music21 import converter, stream
from .plugin_registry import register_plugin

@register_plugin(
    name="convert_to_musicxml",
    description="Converts MIDI files to MusicXML with analysis data",
    version="1.0.0",
    input_type="midi"
)
def convert_to_musicxml(midi_path: str, output_dir: str = "reports/musicxml") -> Dict:
    """
    Convert a MIDI file to MusicXML format.
    
    Args:
        midi_path (str): Path to the MIDI file.
        output_dir (str): Directory to save the MusicXML output.
    
    Returns:
        Dict: MusicXML path or error message.
    """
    try:
        base = os.path.splitext(os.path.basename(midi_path))[0]
        musicxml_path = os.path.join(output_dir, f"{base}.musicxml")
        os.makedirs(output_dir, exist_ok=True)
        
        # Load MIDI file
        score = converter.parse(midi_path)
        
        # Optional: Enhance with metadata
        score.metadata = stream.Metadata()
        score.metadata.title = f"Converted from {base}"
        
        # Save as MusicXML
        score.write('musicxml', musicxml_path)
        
        return {
            "file": midi_path,
            "musicxml_path": musicxml_path,
            "status": "conversion_completed"
        }
    except Exception as e:
        return {"file": midi_path, "error": str(e)}
2. src/score_engraver.py
Generates visual sheet music (PDF and PNG) from MusicXML files using MuseScore’s command-line interface, optimized for WSL by ensuring MuseScore is installed in the Ubuntu environment.
python
# File: src/score_engraver.py
"""
Score Engraver Plugin
Generates sheet music (PDF, PNG) from MusicXML files using MuseScore in WSL.
"""
import os
import subprocess
from typing import Dict
from .plugin_registry import register_plugin

@register_plugin(
    name="engrave_score",
    description="Generates sheet music from MusicXML using MuseScore",
    version="1.0.0",
    input_type="musicxml"
)
def engrave_score(musicxml_path: str, output_dir: str = "reports/scores") -> Dict:
    """
    Generate sheet music from a MusicXML file.
    
    Args:
        musicxml_path (str): Path to the MusicXML file.
        output_dir (str): Directory to save PDF and PNG outputs.
    
    Returns:
        Dict: Sheet music paths or error message.
    """
    try:
        base = os.path.splitext(os.path.basename(musicxml_path))[0]
        pdf_path = os.path.join(output_dir, f"{base}.pdf")
        png_path = os.path.join(output_dir, f"{base}.png")
        os.makedirs(output_dir, exist_ok=True)
        
        # Convert Windows path to WSL path for MuseScore
        wsl_musicxml_path = f"/mnt/{musicxml_path[0].lower()}{musicxml_path[2:].replace('\\\\', '/').replace('\\', '/')}"
        wsl_pdf_path = f"/mnt/{pdf_path[0].lower()}{pdf_path[2:].replace('\\\\', '/').replace('\\', '/')}"
        wsl_png_path = f"/mnt/{png_path[0].lower()}{png_path[2:].replace('\\\\', '/').replace('\\', '/')}"
        
        # Run MuseScore in WSL
        musescore_cmd = [
            "wsl", "musescore3",
            "-o", wsl_pdf_path,
            wsl_musicxml_path
        ]
        subprocess.run(musescore_cmd, check=True, capture_output=True, text=True)
        
        musescore_cmd_png = [
            "wsl", "musescore3",
            "-o", wsl_png_path,
            wsl_musicxml_path
        ]
        subprocess.run(musescore_cmd_png, check=True, capture_output=True, text=True)
        
        return {
            "file": musicxml_path,
            "pdf_path": pdf_path,
            "png_path": png_path,
            "status": "engraving_completed"
        }
    except subprocess.CalledProcessError as e:
        return {"file": musicxml_path, "error": f"MuseScore failed: {e.stderr}"}
    except Exception as e:
        return {"file": musicxml_path, "error": str(e)}
3. src/musicxml_validator.py
Validates MusicXML files for correctness using xml.etree.ElementTree, ensuring compatibility with notation software. It’s designed to run in the Windows environment but can access WSL paths if needed.
python
# File: src/musicxml_validator.py
"""
MusicXML Validator Plugin
Validates MusicXML files for correctness and compatibility.
"""
import os
from typing import Dict
import xml.etree.ElementTree as ET
from .plugin_registry import register_plugin

@register_plugin(
    name="validate_musicxml",
    description="Validates MusicXML files for correctness",
    version="1.0.0",
    input_type="musicxml"
)
def validate_musicxml(musicxml_path: str) -> Dict:
    """
    Validate a MusicXML file.
    
    Args:
        musicxml_path (str): Path to the MusicXML file.
    
    Returns:
        Dict: Validation results or error message.
    """
    try:
        # Parse MusicXML file
        tree = ET.parse(musicxml_path)
        root = tree.getroot()
        
        # Check for required MusicXML elements
        required_elements = ["score-partwise", "part-list", "part"]
        missing_elements = [elem for elem in required_elements if root.find(elem) is None]
        
        if missing_elements:
            return {
                "file": musicxml_path,
                "status": "validation_failed",
                "errors": [f"Missing required element: {elem}" for elem in missing_elements]
            }
        
        # Additional checks
        parts = root.findall("part")
        if not parts:
            return {
                "file": musicxml_path,
                "status": "validation_failed",
                "errors": ["No parts found in MusicXML"]
            }
        
        return {
            "file": musicxml_path,
            "status": "validation_passed",
            "errors": []
        }
    except ET.ParseError as e:
        return {"file": musicxml_path, "status": "validation_failed", "errors": [f"XML parsing error: {str(e)}"]}
    except Exception as e:
        return {"file": musicxml_path, "status": "validation_failed", "errors": [str(e)]}
Integration Guide
To integrate the Phase 4 plugins into your AI Music Assistant, tailored for your WSL setup with the Essentia bridge:
Save Phase 4 Plugins:
Copy-paste the three plugins above into src/:
src/musicxml_converter.py
src/score_engraver.py
src/musicxml_validator.py
Example in WSL or Windows:
bash
nano src/musicxml_converter.py
# Paste the musicxml_converter.py code, then Ctrl+O, Enter, Ctrl+X to save and exit
Or use VS Code in Windows to save to your WSL-mounted src/ directory (e.g., \\wsl$\Ubuntu\home\yourusername\project\src\).
Repeat for score_engraver.py and musicxml_validator.py.
Update main.py for MusicXML Support:
Your current main.py (shared earlier) needs to handle input_type="musicxml". Here’s the updated version, incorporating the musicxml_dir argument:
python
# File: src/main.py
"""
Orchestrator for the AI Music Assistant pipeline.
Dynamically imports all plugins and processes files based on input type.
"""
import os
import json
import argparse
import glob
import importlib.util
from src.plugin_registry import PLUGINS

def import_plugins():
    src_dir = os.path.dirname(__file__)
    for py_file in glob.glob(os.path.join(src_dir, "*.py")):
        module_name = os.path.splitext(os.path.basename(py_file))[0]
        if module_name in ["main", "plugin_registry", "list_plugins"]:
            continue
        spec = importlib.util.spec_from_file_location(module_name, py_file)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)

def main(audio_dir: str, midi_dir: str, musicxml_dir: str, out_dir: str):
    import_plugins()
    os.makedirs(out_dir, exist_ok=True)
    report = []
    print("🔌 Loaded plugins:")
    for idx, plugin in enumerate(PLUGINS, 1):
        print(f"  {idx}. {plugin['name']} ({plugin['input_type']}, v{plugin['version']}) - {plugin['description']}")
    
    for plugin in PLUGINS:
        name = plugin["name"]
        func = plugin["func"]
        input_type = plugin["input_type"]
        print(f"\n▶️ Running plugin: {name}")
        
        if input_type == "midi":
            input_dir = midi_dir
            extension = ".mid"
        elif input_type == "musicxml":
            input_dir = musicxml_dir
            extension = ".musicxml"
        else:  # Default to wav
            input_dir = audio_dir
            extension = ".wav"
        
        for file in os.listdir(input_dir):
            if not file.lower().endswith(extension):
                continue
            path = os.path.join(input_dir, file)
            result = func(path)
            result.update({"plugin": name, "file": file})
            fname = f"{out_dir}/{os.path.splitext(file)[0]}__{name}.json"
            os.makedirs(os.path.dirname(fname), exist_ok=True)
            with open(fname, "w") as f:
                json.dump(result, f, indent=2)
            report.append(result)
    
    with open(f"{out_dir}/master_report.json", "w") as f:
        json.dump(report, f, indent=2)
    print(f"\n✅ All done! Master report at {out_dir}/master_report.json")

if __name__ == "__main__":
    p = argparse.ArgumentParser()
    p.add_argument("--audio_dir", default="input_files/audio")
    p.add_argument("--midi_dir", default="input_files/midi")
    p.add_argument("--musicxml_dir", default="input_files/musicxml")
    p.add_argument("--out_dir", default="reports")
    args = p.parse_args()
    main(args.audio_dir, args.midi_dir, args.musicxml_dir, args.out_dir)
Action: Replace src/main.py with this version. Save it in Windows or WSL (e.g., \\wsl$\Ubuntu\home\yourusername\project\src\main.py).
Handle essentia_bridge.py:
Observation: Your essentia_bridge.py uses @register_stage instead of @register_plugin, suggesting a different registration mechanism (possibly from an earlier or parallel system). It also processes WAV files, similar to audio_features.py.
Recommendation:
To integrate with your current plugin_registry.py, update essentia_bridge.py to use @register_plugin:
python
# File: src/essentia_bridge.py
import subprocess
import json
from src.plugin_registry import register_plugin

@register_plugin(
    name="essentia_analysis",
    description="Runs Essentia analysis on WAV files via WSL",
    version="1.0.0",
    input_type="wav"
)
def run_essentia_bridge(audio_path: str) -> dict:
    try:
        wsl_audio_path = f"/mnt/{audio_path[0].lower()}{audio_path[2:].replace('\\\\', '/').replace('\\', '/')}"
        print(f"[essentia_bridge] Translated path for WSL: {wsl_audio_path}")
        result = subprocess.run(
            ["wsl", "python3", "/home/yourusername/essentia_runner.py", wsl_audio_path],
            capture_output=True,
            text=True,
            timeout=60
        )
        if result.returncode != 0:
            print(f"[essentia_bridge] Error: {result.stderr}")
            return {"error": result.stderr.strip()}
        return json.loads(result.stdout.strip())
    except Exception as e:
        return {"error": str(e)}
Action: Replace src/essentia_bridge.py with this version. Update /home/yourusername/essentia_runner.py to your actual WSL path (e.g., /home/john/essentia_runner.py).
Alternative: If @register_stage is intentional (e.g., for a separate pipeline), keep essentia_bridge.py as-is and clarify how it fits with main.py. I can modify main.py to support @register_stage if needed.
Essentia Runner:
Ensure essentia_runner.py is in your WSL home directory (e.g., /home/yourusername/essentia_runner.py).
Verify Essentia in WSL:
bash
wsl python3 -c "import essentia; print(essentia.__version__)"
If not installed:
bash
wsl pip install essentia
Confirm Existing Files:
Ensure you have:
Phase 1 Plugins (8): audio_analysis.py, audio_features.py, audio_mastering.py, audio_structure.py, audio_vocals.py, audio_roles.py, audio_visualizer.py, audio_summary.py.
Phase 2 Plugins (4): midi_analysis.py, midi_exporter.py, midi_role_classifier.py, midi_visualizer.py.
Phase 3 Plugins (3): audio_to_midi.py, stem_separator.py, whisper_transcriber.py (WhisperX version).
Phase 4 Plugins (3): musicxml_converter.py, score_engraver.py, musicxml_validator.py (above).
Bridge: essentia_bridge.py (updated), essentia_runner.py (in WSL).
Core Files: plugin_registry.py, main.py (updated), list_plugins.py.
Verify:
bash
dir src
Expected (22 files, including essentia_bridge.py):
audio_analysis.py  audio_features.py  audio_mastering.py  audio_roles.py  audio_structure.py  audio_summary.py  audio_to_midi.py  audio_visualizer.py  audio_vocals.py  essentia_bridge.py  list_plugins.py  main.py  midi_analysis.py  midi_exporter.py  midi_role_classifier.py  midi_visualizer.py  musicxml_converter.py  musicxml_validator.py  plugin_registry.py  score_engraver.py  stem_separator.py  whisper_transcriber.py
Install Dependencies:
Existing (Phases 1-3):
bash
pip install librosa essentia numpy matplotlib music21 pretty_midi basic-pitch demucs git+https://github.com/m-bain/whisperx.git
In WSL for Essentia and WhisperX:
bash
wsl pip install essentia git+https://github.com/m-bain/whisperx.git
PyTorch 2.0 and FFmpeg for WhisperX:
bash
wsl bash -c "conda create --name whisperx python=3.10 && conda activate whisperx && conda install pytorch==2.0.0 torchaudio==2.0.0 pytorch-cuda=11.8 -c pytorch -c nvidia && sudo apt update && sudo apt install ffmpeg"
For Phase 4:
bash
pip install music21
In WSL:
bash
wsl pip install music21
MuseScore (for score_engraver.py):
bash
wsl sudo apt update
wsl sudo apt install musescore3
Verify:
bash
wsl musescore3 --version
Prepare Input Files:
Create directories:
bash
mkdir -p input_files/audio input_files/midi input_files/musicxml
Place:
A test WAV file (e.g., test.wav) in input_files/audio/ for Phase 1, 3, and essentia_bridge.py.
A test MIDI file (e.g., test.mid) in input_files/midi/ for Phase 2 and musicxml_converter.py.
A test MusicXML file (e.g., test.musicxml) in input_files/musicxml/ for score_engraver.py and musicxml_validator.py. Generate test.musicxml by running musicxml_converter.py first.
Verify Plugins:
Run:
bash
python src/list_plugins.py
Expected Output (19 plugins: 8 Phase 1, 4 Phase 2, 3 Phase 3, 3 Phase 4, 1 Bridge):
📋 Registered plugins (in import order):
  1. analyze_wav (wav, v1.0.0) - Analyzes WAV files for basic audio properties
  2. analyze_features (wav, v1.0.0) - Extracts audio features using Essentia
  3. analyze_mastering (wav, v1.0.0) - Evaluates mastering quality
  4. extract_structure (wav, v1.0.0) - Detects song structure
  5. analyze_vocals (wav, v1.0.0) - Analyzes vocal presence
  6. analyze_roles (wav, v1.0.0) - Identifies instrument roles
  7. visualize_audio (wav, v1.0.0) - Generates audio visualizations
  8. generate_summary (wav, v1.0.0) - Summarizes analysis results
  9. analyze_midi (midi, v1.0.0) - Analyzes MIDI files for keys, chords, and phrases
 10. export_midi (midi, v1.0.0) - Exports MIDI annotations to MusicXML and JAMS
 11. classify_midi_roles (midi, v1.0.0) - Classifies MIDI tracks as melody, bass, drums, or chords
 12. visualize_midi (midi, v1.0.0) - Generates piano-roll visualizations for MIDI files
 13. transcribe_audio_to_midi (wav, v1.0.0) - Transcribes WAV audio to MIDI using basic-pitch
 14. separate_stems (wav, v1.0.0) - Separates WAV audio into stems using Demucs
 15. transcribe_vocals (wav, v1.0.0) - Transcribes vocals to lyrics using WhisperX with word-level timestamps
 16. convert_to_musicxml (midi, v1.0.0) - Converts MIDI files to MusicXML with analysis data
 17. engrave_score (musicxml, v1.0.0) - Generates sheet music from MusicXML using MuseScore
 18. validate_musicxml (musicxml, v1.0.0) - Validates MusicXML files for correctness
 19. essentia_analysis (wav, v1.0.0) - Runs Essentia analysis on WAV files via WSL
Test the Pipeline:
Run:
bash
python src/main.py --audio_dir input_files/audio --midi_dir input_files/midi --musicxml_dir input_files/musicxml --out_dir reports
Check reports/ for:
reports/musicxml/test.musicxml (from musicxml_converter.py).
reports/scores/test.pdf, test.png (from score_engraver.py).
reports/test__essentia_analysis.json (from essentia_bridge.py).
JSON files for all plugins (e.g., test__convert_to_musicxml.json, test__validate_musicxml.json).
master_report.json.
Addressing Download Issues
You had issues downloading phase2_plugins.zip (likely due to a sandboxed path like sandbox:/mnt/data/). To ensure access:
Manual Save:
Copy-paste the Phase 4 plugins, updated main.py, and essentia_bridge.py into src/.
Save essentia_runner.py in your WSL home directory (e.g., /home/yourusername/essentia_runner.py).
ZIP File:
I can provide a ZIP with:
Phase 1 plugins (8 files).
Phase 2 plugins (4 files).
Phase 3 plugins (3 files, with WhisperX whisper_transcriber.py).
Phase 4 plugins (3 files).
essentia_bridge.py, essentia_runner.py.
plugin_registry.py, main.py (updated), list_plugins.py.
Please provide:
Operating system (confirmed: Windows with WSL Ubuntu).
Browser (e.g., Chrome, Firefox).
Specific download issue (e.g., “no button,” “empty file,” “404 error”).
I’ll generate an HTTP link or alternative.
GitHub Gist:
I can upload all files to a public Gist for download. Confirm if preferred.
Troubleshooting
Essentia Bridge:
If essentia_bridge.py fails:
bash
wsl python3 /home/yourusername/essentia_runner.py /mnt/c/path/to/test.wav
Share errors.
Ensure WSL path translation is correct (e.g., C:\path\to\file → /mnt/c/path/to/file).
MuseScore in WSL:
Verify:
bash
wsl musescore3 --version
If not found:
bash
wsl sudo apt install musescore3
Plugin Registration:
If essentia_analysis doesn’t appear in list_plugins.py, confirm @register_plugin in essentia_bridge.py.
Check plugin_registry.log for errors.
Dependencies:
Verify in WSL:
bash
wsl python3 -c "import essentia, music21, whisperx; print('All installed')"
Share errors.
Pipeline Errors:
Share output from:
bash
python src/list_plugins.py
python src/main.py --audio_dir input_files/audio --midi_dir input_files/midi --musicxml_dir input_files/musicxml --out_dir reports
Notes
Essentia Bridge vs. audio_features.py:
essentia_bridge.py duplicates some functionality of audio_features.py. Consider consolidating:
Replace audio_features.py with essentia_bridge.py if WSL is preferred.
Or update audio_features.py to use the WSL bridge. Want a merged version?
Phase 5 Preview:
Phase 5 (Music Generation) includes plugins like music_generator.py, style_transfer.py, harmony_generator.py. I can provide these next.
Enhancements:
musicxml_converter.py could integrate chords/keys from midi_analysis.py. Interested?
score_engraver.py could use LilyPond in WSL for lighter dependency. Prefer this?
Next Steps
Save the three Phase 4 plugins to src/.
Update main.py and essentia_bridge.py as shown.
Ensure essentia_runner.py is in your WSL home directory.
Install MuseScore and dependencies in WSL.
Run python src/list_plugins.py and share the output.
Test the pipeline and report results.
Clarify your next goal:
Need a ZIP or Gist? Provide browser and download issue details.
Want Phase 5 plugins (music generation)?
Need essentia_bridge.py and audio_features.py merged or other tweaks?
Let me know how to proceed or if you need files re-shared! 🚀